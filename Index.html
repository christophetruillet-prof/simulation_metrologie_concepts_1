<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<title>Simulateur de mesures — séance 1 (axe fixe)</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin:20px; color:#111; }
  h1 { margin-bottom:0.1rem; }
  label { display:block; margin-top:8px; }
  input[type=number] { width:100%; padding:6px; box-sizing:border-box; }
  .row { display:flex; gap:12px; flex-wrap:wrap; }
  .card { border:1px solid #ddd; border-radius:8px; padding:12px; flex:1; min-width:260px; background:#fafafa;}
  button { padding:8px 12px; margin-top:10px; cursor:pointer; }
  #canvasWrap { margin-top:12px; }
  #checkboxRow { margin-top:10px; }
</style>
</head>
<body>
<h1>Simulateur de mesures</h1>
<p class="small">Chaque simulation produit un échantillon de mesures aléatoires. Observe la distribution et calcule la moyenne et l’écart-type de ton échantillon.</p>

<div class="row">
  <div class="card" style="flex:0 0 320px">
    <h3>Paramètres</h3>
    <label>Nombre de mesures (N) :
      <input id="nMesures" type="number" value="30" min="5">
    </label>
    <label>Nombre de classes (laisser vide pour calcul auto) :
      <input id="nClasses" type="number" min="1" placeholder="auto">
    </label>
    <div id="checkboxRow">
      <input type="checkbox" id="showGauss" />
      <label for="showGauss" style="display:inline;">Superposer la gaussienne</label>
    </div>
    <button id="runBtn">Lancer la simulation</button>
  </div>

  <div class="card">
    <h3>Résultats</h3>
    <div><strong>Moyenne de l’échantillon :</strong> <span id="meanSample">—</span></div>
    <div><strong>Écart-type de l’échantillon :</strong> <span id="sdSample">—</span></div>
    <div id="canvasWrap">
      <canvas id="histCanvas" width="800" height="300" style="width:100%;border:1px solid #ccc;border-radius:6px"></canvas>
    </div>
  </div>
</div>
<script scr = "chartmin.js"></script>
<script>
/* Générateur normal (Box-Muller) */
function randn_bm() {
  let u=0, v=0;
  while(u===0) u=Math.random();
  while(v===0) v=Math.random();
  return Math.sqrt(-2.0*Math.log(u)) * Math.cos(2.0*Math.PI*v);
}

/* Moyenne et écart-type */
function mean(arr){ return arr.reduce((a,b)=>a+b,0)/arr.length; }
function sdSample(arr){
  const m = mean(arr);
  const s2 = arr.reduce((a,b)=>a + (b-m)*(b-m),0)/(arr.length-1 || 1);
  return Math.sqrt(s2);
}

/* Histogramme : bornes fixes autour de 30 */
function makeHistogram(data, nBins, xmin, xmax) {
  const N = data.length;
  const range = xmax - xmin;
  const binW = range / nBins;
  const bins = new Array(nBins).fill(0);
  data.forEach(v=>{
    let idx = Math.floor((v - xmin)/binW);
    if (idx<0) idx=0;
    if (idx>=nBins) idx=nBins-1;
    bins[idx]++;
  });
  return {bins, xmin, xmax, binW, N};
}

/* Fonction densité normale (µ, σ) */
function normalPdf(x, mu, sigma) {
  return (1/(sigma*Math.sqrt(2*Math.PI))) * Math.exp(-0.5 * ((x-mu)/sigma)**2);
}

/* Dessin histogramme + gaussienne correctement mise à l'échelle */
function drawHistogram(canvas, hist, showGauss) {
  const ctx = canvas.getContext('2d');
  const width = canvas.width, height = canvas.height;
  ctx.clearRect(0,0,width,height);
  const m = {l:40,r:10,t:10,b:30};
  const w = width - m.l - m.r, h = height - m.t - m.b;
  const maxCount = Math.max(...hist.bins) || 1;
  const binWpx = w / hist.bins.length;

  // axes
  ctx.strokeStyle = '#444';
  ctx.beginPath();
  ctx.moveTo(m.l, m.t);
  ctx.lineTo(m.l, m.t + h);
  ctx.lineTo(m.l + w, m.t + h);
  ctx.stroke();

  // barres
  ctx.fillStyle = '#0a58ca33';
  for (let i=0;i<hist.bins.length;i++){
    const b = hist.bins[i];
    const barH = (b / maxCount) * (h);
    ctx.fillRect(m.l + i*binWpx + 1, m.t + h - barH, binWpx - 2, barH);
  }

  // labels x
  ctx.fillStyle = '#000';
  ctx.font = '12px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(hist.xmin.toFixed(1), m.l, m.t + h + 18);
  ctx.fillText('30', m.l + w/2, m.t + h + 18);
  ctx.fillText(hist.xmax.toFixed(1), m.l + w, m.t + h + 18);

  // superposition de la gaussienne N(30,1)
  if (showGauss) {
    const mu = 30.0, sigma = 1.0;
    ctx.beginPath();
    for (let xpixel=0; xpixel<=w; xpixel++){
      const xVal = hist.xmin + (xpixel/w)*(hist.xmax - hist.xmin);
      const pdf = normalPdf(xVal, mu, sigma);
      const expectedCountInBin = pdf * hist.N * hist.binW; 
      const pixelHeight = (expectedCountInBin / maxCount) * h;
      const y = m.t + h - pixelHeight;
      if (xpixel===0) ctx.moveTo(m.l + xpixel, y);
      else ctx.lineTo(m.l + xpixel, y);
    }
    ctx.strokeStyle = '#e74c3c';
    ctx.lineWidth = 2;
    ctx.stroke();
  }
}

/* Simulation principale */
document.getElementById('runBtn').addEventListener('click', ()=>{
  const nInput = parseInt(document.getElementById('nMesures').value);
  const n = Math.max(5, isNaN(nInput) ? 30 : nInput);
  const nClassesInput = parseInt(document.getElementById('nClasses').value);
  const showGauss = document.getElementById('showGauss').checked;
  const mu = 30.0, sigma = 1.0;

  const data = [];
  for (let i=0;i<n;i++){
    data.push(mu + sigma * randn_bm());
  }

  const meanVal = mean(data);
  const sdVal = sdSample(data);

  // Si pas de nombre de classes indiqué, calcul automatique
  const log10 = Math.log10 ? Math.log10(n) : Math.log(n)/Math.LN10;
  const autoBins = Math.floor(1 + log10 * 10 / 3) || 1;
  const nBins = (isNaN(nClassesInput) || nClassesInput <= 0) ? autoBins : nClassesInput;

  document.getElementById('meanSample').textContent = meanVal.toFixed(3);
  document.getElementById('sdSample').textContent = sdVal.toFixed(3);

  // Axe figé autour de 30
  const xmin = 26.0, xmax = 34.0;
  const hist = makeHistogram(data, nBins, xmin, xmax);
  drawHistogram(document.getElementById('histCanvas'), hist, showGauss);
});
</script>
</body>
</html>
